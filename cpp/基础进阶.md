

### 一、static的用法

static 是 C/C++ 中很常用的修饰符，它被用来控制变量的**存储方式**和**可见性**。

#### 1. static 的引入

我们知道在函数内部定义的**变量**，当程序执行到它的定义处时，编译器为它在**栈**上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 最容易想到的方法是定义为全局的变量，但定义一个全局变量有许多缺点，最明显的缺点是**破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅只受此函数控制）**。static 关键字则可以很好的解决这个问题。另外，在 C++ 中，需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此**成员隐藏在类的内部，对外不可见时**，可将其定义为静态数据。



#### 2. 静态数据的存储

**全局（静态）存储区**：分为 DATA 段和 BSS 段。**DATA 段（全局初始化区）**存放初始化的全局变量和静态变量；**BSS 段（全局未初始化区）**存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，

内存分布图：

**代码区：**			存储代码
**全局数据区：**	static 数据、全局变量、const 常量
**堆区：**			   **new** 出来的动态数据， 需手动释放。若忘记释放会造成**内存泄漏**，在程序结束时由操作系统回收。
**栈区：**			   函数内部变量，由IDE自动分配，结束时自动释放。



#### 3. 在 C/C++ 中static的作用

（1）在修饰变量的时候，static 修饰的静态局部变量只执行**初始化一次**，而且延长了局部变量的生命周期，**直到程序运行结束**以后才释放。

（2）static 修饰全局变量的时候，这个全局变量只能在**本文件中访问**，不能在其它文件中访问，即便是 **extern 外部声明也不可以**。

（3）static 修饰一个函数，则这个函数的只能在**本文件中调用**，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。

（4）**不想被释放**的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。

（5）考虑到**数据安全性**（当程序想要使用全局变量的时候应该**先考虑使用 static**）。



#### 4. 类中 static 用法

（1）可以通过类名来调用类的静态成员函数/变量；不能通过类名来调用类的非静态成员函数/变量。

（2）类的对象可以使用静态成员函数和非静态成员函数。

（3）静态成员函数中不能引用非静态成员，反之可以。

（4）静态成员变量使用前必须先初始化(如 **int MyClass::m_nNumber = 0;**)，否则会出错。

（5）非静态成员函数有 this 指针，而静态成员函数没有 this 指针。

参考：

[1] [菜鸟教程](https://www.runoob.com/w3cnote/cpp-static-usage.html)

[2] [博客园](https://www.cnblogs.com/33debug/p/7223869.html)





### 二、C++ const 小结

const 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰**内置类型变量，自定义对象，成员函数，返回值，函数参数**。

C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有**某个值保持不变**，就应该明确使用const，这样可以获得编译器的帮助。

#### 1. const修饰普通类型的变量

```c++
const int  a = 7;
int  b = a; // 正确
a = 8;       // 错误，不能改变

//不要试图对const变量设法赋值
int *p = (int*)&a;
*p = 8; 
cout << a << endl; //出现矛盾，输出a=7
cout << *b << endl; //*b=8
```



#### 2. const 修饰指针变量。

const 修饰指针变量有以下三种情况。

- A: const 修饰指针指向的内容，则内容为不可变量。
- B: const 修饰指针，则指针为不可变量。
- C: const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。

```C++
const int* a=8; //A
int const* a=8; //A

int d = 1;
int* const b = &d; //B

int e = 2;
const int* const c=&e; //C
int const* const c=&e; //C
```



#### 3. const参数传递和函数返回值。

**对于 const 修饰函数参数可以分为三种情况：**

A：值传递的 const 修饰传递，一般这种情况不需要 const 修饰，因为函数会自动产生临时变量复制实参值。



B：当 const 参数为指针时，可以防止指针被意外篡改。



C：自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。

并且对于一般的 int、double 等内置类型，我们不采用引用的传递方式，**引用是4个字节**。



**对于 const 修饰函数的返回值：**

A：const 修饰内置类型的返回值，修饰与不修饰返回值作用一样。

B: const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。

C: const 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让用户干什么。



#### 4. const修饰类成员函数

const 修饰类成员函数，其目的是**防止成员函数修改被调用对象的值**，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。

**注意：const 关键字不能与 static 关键字同时使用**，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。

[1] [菜鸟教程](https://www.runoob.com/w3cnote/cpp-const-keyword.html)

[2] [博客园](https://www.cnblogs.com/Forever-Kenlen-Ja/p/3776991.html)